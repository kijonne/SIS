; Lab 5: Studying input-output methods in assembler
; All tasks in one file, 64-bit mode in SASM IDE

section .data
    scan_fmt db "%lf %lf", 0                ; Format for scanf: two doubles separated by space
    print_fmt db "Hypotenuse: %lf", 10, 0   ; Format for printf: output hypotenuse with newline
    msg_text db "Repeat input?", 0          ; MessageBox text
    msg_title db "Question", 0              ; MessageBox title

section .bss
    cat1 resq 1                             ; First cathet (double)
    cat2 resq 1                             ; Second cathet (double)
    hyp resq 1                              ; Hypotenuse (double)

section .text
    global main
    extern scanf, printf, MessageBoxA, ExitProcess

main:
    push rbp
    mov rbp, rsp                            ; Set up stack frame

.start_loop:

    ; 5.1: Read two cathets (doubles) using scanf into variables
    lea rcx, [scan_fmt]                     ; First arg: format string
    lea rdx, [cat1]                         ; Second arg: address of cat1
    lea r8, [cat2]                          ; Third arg: address of cat2
    sub rsp, 0x20                           ; Reserve shadow space (32 bytes)
    call scanf                              ; Call scanf
    add rsp, 0x20                           ; Restore stack

    ; 5.2: Calculate hypotenuse length using math coprocessor
    fld qword [cat1]                        ; Load cat1 to FPU stack
    fmul st0, st0                           ; Square cat1 (cat1 * cat1)
    fld qword [cat2]                        ; Load cat2 to FPU stack
    fmul st0, st0                           ; Square cat2 (cat2 * cat2)
    faddp st1, st0                          ; Add squares (st1 = cat1^2 + cat2^2)
    fsqrt                                   ; Take square root (hyp = sqrt(cat1^2 + cat2^2))
    fstp qword [hyp]                        ; Store result to hyp and pop FPU stack

    ; 5.3: Output the result using printf
    ; Note: For variadic functions like printf in Windows x64 ABI, floating-point args must be in both XMM and corresponding integer registers
    lea rcx, [print_fmt]                    ; First arg: format string
    movsd xmm1, qword [hyp]                 ; Second arg (float): load to XMM1
    movq rdx, xmm1                          ; Duplicate float bits to RDX (general register)
    sub rsp, 0x20                           ; Reserve shadow space
    call printf                             ; Call printf
    add rsp, 0x20                           ; Restore stack

    ; 5.4: Show MessageBox asking to repeat or exit
    xor rcx, rcx                            ; First arg: hWnd = 0 (no owner window)
    lea rdx, [msg_text]                     ; Second arg: text
    lea r8, [msg_title]                     ; Third arg: title
    mov r9d, 4                              ; Fourth arg: uType = MB_YESNO (4)
    sub rsp, 0x20                           ; Reserve shadow space
    call MessageBoxA                        ; Call MessageBoxA
    add rsp, 0x20                           ; Restore stack
    cmp rax, 6                              ; Compare return value: IDYES = 6
    je .start_loop                          ; If yes, repeat loop

    ; Exit program
    xor ecx, ecx                            ; Exit code 0
    call ExitProcess                        ; Call ExitProcess (from kernel32.dll)

    pop rbp                                 ; Restore stack frame (though ExitProcess doesn't return)
    ret                                     ; Return (safety)
